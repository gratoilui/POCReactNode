<!--
Composant représente le "whiteboard"
Le composant a deux modes :
    -modeUser => pour les utilisateurs permettant aux utilisateurs de s'inscrire et d'écrire
    -mode normal => pour le "whiteboard" à projeter qui contient la liste des utilisateurs inscrit
-->
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="../../bower_components/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../../bower_components/paper-styles/paper-styles.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html"/>
<link rel="import" href="../../bower_components/paper-header-panel/paper-header-panel.html"/>
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html"/>

<dom-module id="component-whiteboard">
    <link rel="import" type="css" href="style.css">
    <template>
        <!--
            Partie representant le white board
        -->
        <input id="textBox" />
        <div id="whiteboard" class="layout horizontal">
            <paper-header-panel class="blue">
                <div class="paper-header">Brainstorming</div>
                <div class="style-scope paper-header-panel" >
                    <canvas id="canvas" width="1400" height="650"></canvas>
                </div>
            </paper-header-panel>
            <paper-header-panel id="userList" class="green">
                <div class="paper-header">Utilisateurs</div>
                <paper-listbox selected="1" class="style-scope paper-header-panel">
                    <template is="dom-repeat" items="{{users}}" as="user">
                        <paper-icon-item>
                            <!-- style$ pour pouvoir mixer du texte avec du data binding -->
                            <div class="avatar" style$="background-color:{{user.color}}" item-icon></div>{{user.name}}
                        </paper-icon-item>
                    </template>
                </paper-listbox>
            </paper-header-panel>
        </div>

        <!--
            Formulaire d'inscription de l'utilisateur, visible à l'arrivée de l'utilisateur sur la page
        -->
        <paper-dialog id="connection" modal>
            <paper-header-panel class="blue">
                <div class="paper-header">Veuillez vous identifier</div>
                <div class="style-scope paper-header-panel flex-vertical">
                    <div>
                        <paper-input id="user" label="Nom d'utilisateur" autofocus></paper-input>
                    </div>
                    <div>
                        <paper-button raised id="connect">Se connecter</paper-button>
                    </div>
                </div>
            </paper-header-panel>
        </paper-dialog>

    </template>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        Polymer({
            currentMousePos: {
                x : 0,
                y : 0
            },
            canvas: null,
            socket: null,
            //Ecoute des evenements sur le composant
            listeners: {
                'canvas.click' : 'showContentBox',
                'textBox.keypress' : 'insertText',
                'connect.click' : 'connection',
                'user.keypress' : 'connection'
            },
            properties : {
                modeuser: false //mode d'utilisation du composant, false = whiteboard, '' = mode utilisateur
            },
            getMousePos : function (canvas, evt) {
                var rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            },
            //Permet de rendre visible la zone de texte à l'endroit du clique de l'utilisateur
            showContentBox : function (e) {
                Polymer.dom(this.root).querySelector('#textBox').style.display='block';
                Polymer.dom(this.root).querySelector('#textBox').style.top = e.clientY+"px";
                Polymer.dom(this.root).querySelector('#textBox').style.left = e.clientX+"px";
                Polymer.dom(this.root).querySelector('#textBox').focus();
                this.currentMousePos = this.getMousePos(this.canvas, e);
            },
            //Permet d'informer les clients d'un nouveau message
            insertText : function(e){
                //Lors de la touche entrée on informe l'ensemble des "whiteboard" du texte inséré
                //pour qu'ils se mettent à jour
                if(e.keyCode == 13) {
                    this.socket.emit('chat_msg', {
                        'content': e.target.value,
                        'pos': this.currentMousePos
                    });
                    //On cache la zone de texte
                    Polymer.dom(this.root).querySelector('#textBox').style.display='none';
                    Polymer.dom(this.root).querySelector('#textBox').value = '';
                }
            },
            //Permet d'écrire un message dans le canvas
            writeMessage : function(context, msg, x, y, color) {
                context.font = '18pt Calibri';
                context.fillStyle = color;
                context.fillText(msg, x, y);
            },
            //Permet de cacher le formulaire de connection et d'afficher le whiteboard
            connection : function(e) {
                //Lors de la touche entrée on informe l'ensemble des "whiteboard" du texte inséré
                //pour qu'ils se mettent à jour
                //e.keyCode si event de touche entree, !e.keyCode si clique sur le bouton
                if(e.keyCode == 13 || !e.keyCode) {
                    Polymer.dom(this.root).querySelector("#connection").close();
                    var userName = Polymer.dom(this.root).querySelector("#user").value;
                    var msg = {username: userName};
                    this.socket.emit('chat_cnx', msg);
                }
            },
            //Permet d'initiliser le canvas
            initCanvas : function() {
                this.canvas = Polymer.dom(this.root).querySelector('#canvas');
                this.socket = io();
                var ctx = this.canvas.getContext('2d');
                var randomID = Math.random();
                //On demande au serveur les messages courant de manière à initialiser le canvas à
                this.socket.emit('init',{counter : randomID});
                var _this = this;
                this.socket.on('init'+randomID, function(msg){
                    _this.update(msg.textSave);
                });

                //Ecoute de l'event chat_msg de socket IO pour inserer un message
                this.socket.on('chat_msg', function(msg){
                    _this.writeMessage(ctx, msg.content, msg.pos.x, msg.pos.y, msg.color);
                });
            },
            update : function(textSave) {
                // on l'initialisation est déjà réalisé pour ce client, la prochaine fois on ne veut pas le faire
                if(textSave) {
                    for (var i = 0; i < textSave.length; i++) {
                        this.writeMessage(this.canvas.getContext('2d'), textSave[i].content, textSave[i].pos.x, textSave[i].pos.y, textSave[i].color);
                    }
                }
            },
            updateUsers : function(users) {
                // on l'initialisation est déjà réalisé pour ce client, la prochaine fois on ne veut pas le faire
                if(users){
                    for(var key in users) {
                        this.addUser(users[key].name, users[key].color);
                    }
                }

            },
            //permet d'ajouter un utilisateur à la liste
            addUser : function(name, color) {
                if(!this.users){
                    this.users = [];
                }
                this.push('users',{name : name, color : color});
            },
            //permet de supprimer un utilisateur à la liste
            removeUser : function(name) {
                if(this.users){
                    for(var i = 0 ; i< this.users.length ; i++){
                        if(this.users[i].name == name) {
                            this.splice("users", i, 1);
                            break;
                        }
                    }
                }
            },
            //Event au moment où notre composant est pret à être utilisé
            ready : function(e) {
                //initilisation du canvas
                this.initCanvas();
                //Si mode utilisateur on affiche seulement le formulaire de connection pour commencer
                if(this.modeuser == ''){
                    Polymer.dom(this.root).querySelector("#userList").style.display = "none";
                    Polymer.dom(this.root).querySelector("#connection").open();
                }
                //Sinon on affiche le whiteboard
                else {
                    var self = this;
                    //Ecoute de l'évent adduser pour ajouter un utilisateur à la liste
                    this.socket.on('adduser', function(msg){
                        self.addUser(msg.username, msg.color)
                    });
                    var randomID = Math.random();
                    //On demande au serveur les messages courant de manière à initialiser le canvas à
                    this.socket.emit('initUsers',{counter : randomID});
                    this.socket.on('initUsers'+randomID, function(msg){
                        self.updateUsers(msg.users)
                    });
                    //Ecoute de l'évent removeuser pour supprimer un utilisateur à la liste
                    this.socket.on('removeuser', function(msg){
                        self.removeUser(msg.username)
                    });
                }
            }
        });
    </script>
</dom-module>